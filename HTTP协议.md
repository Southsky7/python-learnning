# 	HTTP协议

- URL：Uniform Resource Locator,统一资源定位，即网络地址，类似www.baidu.com

### 使用HTTP协议访问Web

- 输入URL时，Web浏览器从Web服务器端获取文件资源(resource)等信息从而显示出web页面。
- 像这种通过发送请求获取服务器资源的Web浏览器等都可称为客户端(Client)
- Web使用HTTP(HyperText Transfer Protocol,超文本传输协议)作为规范完成从客户端到服务器端一系列运作流程，可以说Web是建立在HTTP协议上通信的

### HTTP的诞生

- CERN(欧洲核子研究组织)的蒂姆伯纳斯李博士提出了一种能让远隔两地的研究者们共享知识的设想，最初设想的基本理念是:借助多文档之间相互关联形成的超文本连成可互相参阅的WWW(World Wide Web,万维网)
- 到今天已提出了3项WWW构建技术，分别是
  - 把SGML(Standard Generalized Markup Language,标准通用标记语言)作为页面的文本标记语言的HTML
  - 作为文档传递协议的HTTP
  - 指定文档所在地址的URL
- 1997年1月公布的HTTP/1.1是目前主流的HTTP协议版本，可见作为Web文档传输协议的HTTP版本几乎没有更新，HTTP/2.0正在制定，但达到较高覆盖率仍需较长时间。
- 当年HTTP出现是为了解决文本传输的难题，由于协议本身十分简单，于是在此基础上设想了很多应用方法并投入了实际使用，现在HTTP协议已经超出了Web这个框架的局限，被运用到了各种场景里。

### 网络基础TCP/IP

- 通常使用的网络是在TCP/IP协议族的基础上运作的，而HTTP属于它内部的一个自己。
- 不同的硬件、操作系统之间的通信都需要一种规则，这种规则称为协议。把与互联网相关联的协议集合起来总称为TCP/IP。

### TCP/IP的分层管理

- TCP/IP协议按层次分为4层:应用层、传输层、网络层和数据链路层。

### 1.应用层

- 应用层决定了向用户提供应用服务时通信的活动。
- TCP/IP协议族内预存了各类通用的应用服务，如FTP(File Transfer Protocol,文件传输协议)、DNS(Domain Name System,域名系统)等。
- HTTP协议也属于应用层。

#### 2.传输层

- 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。
- 在传输层有两个性质不同的协议：TCP(Transmission Control Protocol,传输控制协议)和UDP(User Data Protocol,用户数据报协议)

#### 3.网络层，又名网络互连层

- 网络层用于处理在网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径(即传输路线)到达对方计算机并把数据包传给对方。
- 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。
- IP协议属于该层

#### 4.链路层，又名数据链路层，网络接口层

- 用来处理网络连接的硬件部分，包括控制操作系统、硬件的设备驱动、NIC(NetWork Interface Card,网络适配器，即网卡)及光纤等物理可见部分，硬件上的范畴均在链路层的作用范围之内。

### TCP/IP通信传输流

- ![image-20211020150312043](http://r19kczb6x.hn-bkt.clouddn.com/img/image-20211020150312043.png)

- 利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信，发送端从应用层往下走，接收端则从链路层往上走。
- 以HTTP举例，作为发送端的客户端在应用层(HTTP协议)发出一个想看某个Web页面的HTTP请求，为了传输方便，在传输层(TCP协议)把应用层处收到的数据(HTTP请求报文)进行分割，并在各个报文上打上标记序号及端口号后发送给网络层。在网络层(IP协议)增加作为通信目的地的MAC地址后转发给链路层，这样发送网络的通信请求就准备齐全了。
- 接收端的服务器在链路层收到数据，按序向上发送，当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。
- 发送端在层层传输时每经过一层必定会被打上一个该层所属的首部信息，反之，接收端会逐层消去信息。
- 这种把数据信息包装起来的做法叫做封装。

### 与HTTP关系密切的协议:IP、TCP和DNS

#### 1.负责传输的IP协议

- 按层次分，IP(Internet Protocol)网际协议位于网络层，IP与IP地址不同，IP是一种协议的名称。
- IP协议的作用是把各种数据包传送给对方，而要确保确实传送到对方需要满足各类条件，其中两个最重要的条件是IP地址和MAC地址(Media Access Control Address，媒体存取控制地址)。
- MAC地址，直译为媒体存取控制地址，也称为局域网地址(LAN Address),MAC位址，以太网地址(Ethernet Address)或物理地址(Physical Address),它是一个用来确认网络设备位置的位址。在OSI模型中，第三层网络负责IP地址，第二层数据链路层负责MAC位址.MAC地址用于在网络中唯一标示一个网卡，一台设备，每个网卡需要并会有唯一的MAC地址。
- IP地址指明了节点被分配到的地址，MAC地址是网卡所属的固定地址，IP地址可与MAC地址进行配对，IP地址可变换，MAC地址基本不变。

##### 使用ARP协议凭借MAC地址进行通信

- IP间的通信依赖MAC地址，网络上通信双方在同一局域网(LAN)情况很少，通常是经过多台计算机和网络设备中转才能连接到对方，在中转是会利用下一站中专设备的MAC地址来搜索下一个中转目标，这时会采用ARP协议(Address Resolution Protocol，地址解析协议)，根据通信方的IP地址就可以反查出对应的MAC地址。
- 在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线，这种机制称为路由选择。

#### 2.确保可靠性的TCP协议

- TCP位于传输层，提供可靠的字节流服务，字节流服务(Byte Stream Service)是指为了方便运输将大块数据分割成以报文段(segment)为单位的数据包进行管理，可靠的传输服务指能把数据准确可靠的传给对方，即TCP协议是为了更容易传送大数据才把数据分割，且TCP协议能够确认数据最终是否送达到对方。

- ##### 确保数据能到达目标

  - 为了准确无误的将数据送达目标处，TCP协议采用了三次握手(three-way handshaking)策略，用TCP协议把数据包送出去后，TCP会向对方确认是否成功送达，握手过程中使用了TCP的标志(flag)-SYN(synchronize)和ACK(acknowledgement)。
  - 发送端先发送一个带SYN标志的数据包给对方，接收端收到后会回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后发送端再回传一个带ACK标志的数据包代表握手结束。
  - 若在握手过程中某个阶段莫名中断，TCP协议会在此以相同顺序发送数据包。

#### 3.负责域名解析的DNS服务

- DNS(Domain Name System,域名系统)服务是和HTTP协议一样位于应用层的协议，它提供域名到IP地址之间的解析服务。
- 计算机既可以被赋予IP地址，也可以被赋予主机名和域名。
- 用户通常使用主机名或域名访问对方计算机，因为IP地址纯数字不好记忆，但计算机更擅长处理数字，因此DNS诞生，DNS协议通过域名查找IP地址或逆向服务。

### 统一资源标识符URI  Uniform Resource Identifier

- Uniform:规定统一的格式可方便处理多种不同类型的资源而不同根据上下文环境来识别资源指定的访问方式且加入新增的协议方案(如http、ftp)也更容易。

- Resource:资源的定义是可标识的任何东西，如文档文件，图像，服务

- Identifier:可标识的对象，即标识符。

- 综上，URI是由某个协议方案表示的资源的定位标识符，协议方案指访问资源所使用的协议类型名称

- 采用HTTP协议时，协议方案就是HTTP，标准URI协议方案有30种，如ftp、telnet、net、mailto

- URI用字符串标识某一资源而URL表示资源的地点，so URL是URI的子集/

- 常见URI:

  - http://www.baidu.com
  - ftp://ftp.is.co.za/rfc/rfc1808.txt
  - telnet://192.0.2.16:80/

  ![image-20211020165826356](http://r19kczb6x.hn-bkt.clouddn.com/img/image-20211020165826356.png)

- 登录信息(认证)：指定用户名和密码作为从服务器端获取资源时必要的登录信息(身份认证),可选项
- 服务器地址:使用绝对URI必须指定待访问的服务器地址。
- 服务器端口号:指定服务器连接的网络端口号，用户省略则自动使用默认端口号
- 带层次的文件路径:指定服务器上的文件路径来定位特指的资源
- 查询字符串:针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数，可选项。
- 片段标识符:使用片段标识符通常可标记处已获取资源种的子资源，可选项

## HTTP基础

- HTTP协议用于客户端与服务器之间的通信
- HTTP协议规定请求从客户端发出，最后服务器响应该请求且返回。 
- ![image-20211020175445263](http://r19kczb6x.hn-bkt.clouddn.com/img/image-20211020175445263.png)

#### 发送请求:

- GET表示请求访问服务器的类型，称为方法，字符串指明了请求访问的资源对象，也叫请求URI(request-URI),最后的HTTP/1.1,用来提示客户端使用的HTTP协议功能。
- 请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。

#### 响应请求：

- 开头的HTTP/1.1表示版本，200 OK表示请求的处理结果的状态码(status code)和原因短语(reason-phrase).下一行是创建响应的日期时间，以一个空行分隔，之后内容称为资源实体的主体。
- 响应报文由协议版本、状态码(表示成功或失败的数字代码)、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。



- HTTP是一种不保存状态，即无状态stateless协议，其自身不对请求和响应之间的通信状态进行保存。
- 为了保存用户状态，引入了Cookie技术用于管理状态。
- HTTP协议使用URI定位互联网上的资源，客户端发送请求时，URI需要将作为请求报文种的请求URI包含在内。
- 对服务器本身发起请求时可用*代替请求URI

### 告知服务器意图的HTTP方法

#### 1.GET:获取资源

- 用于请求访问已被URI识别的资源，指定的资源经服务器端解析后返回响应内容。 

#### 2.POST:传输实体主体

- GET方法也可以传输主体，但一般用POST方法，POST方法主要是传输，不是获取响应。

#### 3.PUT:传输文件

- 妖气再请求报文主题包含文件内容然后保存在请求URI指定位置。但由于PUT方法不带验证机制，有安全问题，一般Web网站不用此方法。

#### 4.HEAD:获得报文首部

- 与GET方法一样，但不返回主体部分，用于确认URI的有效性及资源更新的日期时间。

#### 5.DELETE:删除文件

- 与PUT相反，用于删除请求URI指定的资源，但也不带验证机制，所以一般不用。

#### 6.OPTIONS:询问支持的方法

- 用于查询对请求URI指定的资源支持的方法。

#### 7.TRACE:追踪路径

- 让Web服务器将之前的请求通信返回给客户端的方法
- 易引发XST(Cross-Site Tracing，跨站追踪)攻击，不怎么用。

#### 8.CONNECT：要求用隧道协议连接代理

- 此方法要求与代理服务器通信时建立隧道用于TCP通信，主要使用SSL(Secure Sockets Layer,安全套接层)和TLS(Transport Layer Security,传输层安全)协议把通信内容加密后经网络隧道传输。
- 格式：CONNECT 代理服务器名:端口号 HTTP版本

### 持久连接

- HTTP初始版本每进行一次HTTP通信就要断开一次TCP连接。
- 持久连接特点是只要一段未提出断开连接就保持TCP连接状态。减少了TCP重复建立和断开的额外开销，减轻了服务器端的负载，使HTTP请求和响应更早结束，Web显示时间提高。
- 持久连接使管线化称为可能，最初发送请求后得到响应才能发送下一个请求，管线化之后可用并行发送多个请求。

### Cookie

- Cookie技术通过在请求和响应报文种写入Cookie信息来控制客户端状态。
- Cookie根据响应报文中的Set-Cookie首部字段信息，通知客户端保存Cookie，当下次客户端在往服务器发送请求时，客户端会自动在请求报文中添加Cookie值，服务器通过对比Cookie值就知道从哪个客户端发来信息，从而得到之前的状态信息。

## HTTP报文

![image-20211020224848478](http://r19kczb6x.hn-bkt.clouddn.com/img/image-20211020224848478.png)

![image-20211020224900773](http://r19kczb6x.hn-bkt.clouddn.com/img/image-20211020224900773.png)

- 用于HTTP协议交互的信息被称为HTTP报文，分为请求报文和响应报文。其本身是有多行数据构成的字符串文本。

- 不一定要有报文主体。

- #### 首部内容组成

  - 请求行：包含用于请求的方法，请求URI和HTTP版本
  - 状态行：包含表明响应结果的状态码，原因短语和HTTP版本
  - 首部字段：包含请求和响应的各种条件和属性的各类首部。首部有4种:通用首部、请求首部、响应首部和实体首部
  - 其他，如HTTP的RFC里未定义的首部(Cookie等)

#### 编码提升传输速率

- HTTP在传输数据时可以按数据样貌直接传输也可以在传输过程中通过编码提升传输速率，但编码由计算机完成因此会消耗更多CPU资源。
- 报文message：HTTP通信的基本单位，由8位组字节流(octet sequence,octet为8个比特)组成，通过HTTP通信传输
- 实体entity:作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。
- HTTP报文的主体用于传输请求或响应的实体主体，通常二者相等，仅当传输时进行编码操作时，实体主体内容变化，才与报文主体产生差异。

#### 压缩传输的内容编码

- 内容编码指应用在实体内容上的编码格式，并保持实体信息原样压缩，编码后的实体由客户端接收并负责解码。
- 常见内容编码：
  - gzip(GNU zip)
  - compress(UNIX系统的标准压缩)
  - deflate(zlib)
  - identify(不进行编码)

#### 分块传输编码

- 传输大容量数据时通过把数据分割成多块，能够让浏览器逐步显示页面，这种把实体主体分块的功能称为分块传输编码Chunked Transfer Coding
- 分块传输编码把实体主体分成多个部分，每块都用十六进制标记块的大小，实体主体的最后一块用0(CR+LF)来标记。实体主体由客户端负责解码，恢复到编码前的实体主体。

### MIME

- 发送邮件时可以添加多份附件是因为采用了MIME机制，Multipurpose Internet Mail Extensions,多用途因特网邮件扩展，它允许邮件处理文本、图片、视频等多个不同类型的数据，MIME扩展中使用了称为多部份对象集合(Multipart)的方法来容纳多份不同类型的数据。
- HTTP协议也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体，通常是在图片或文本文件等上传时使用。
- 多部份对象集合包含的对象：
  - multipart/form-data:在Web表单文件上传时使用
  - multipart/byteranges:状态码206(Partial Conent,部分内容)响应报文包含多个范围的内容时使用。
  - HTTP报文中使用多部份对象集合时，需要在首部字段里加上Content-type。
  - 使用boundary字符串来划分多部份对象集合指明的各类实体。在boundary字符串指定的各个实体起始行之前插入--(如--AaB03x)标记，在最后插入--如(--AaB03x--)作为结束
  - 多部份集合对象每个部分类型都可以含有首部字段且可以在某个部分嵌套使用多部分对象集合。

### 获取部分内容的范围请求

- 以前下载过程中若中断就需要重新下载，为了解决此问题，需要一种可恢复的机制，即从中断处恢复下载。
- 要实现该功能需要指定下载的实体范围，指定范围发送的请求叫做范围请求。
- 对一份10000字节大小的资源，使用范围请求只能请求5001~1000字节内的资源。
- 执行范围请求时，使用首部字段Range来指定资源的byte范围。

- 5001~10000字节：Range:bytes = 5001 - 10000       5001字节之后全部的:Range:bytes:5001 - 
- 多重范围，如开始到3000字节和5000~7000字节：Range:bytes = 0 - 3000,5000-7000
- 针对范围请求，响应返回状态码为206 Partial Conent的响应报文且对于多重范围的范围请求，响应会在首部字段Conent-Type标明multipart/byteranges后返回响应报文。若服务器无法响应范围请求，则会返回状态码200 OK和完整实体内容。

### 内容协商

- 同一个Web网站可能存在多份内容相同的页面，如中文和英文页面，内容相同却语言不同，当浏览器默认语言为中文则浏览器对应显示中文，这种机制叫内容协商
- 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉然后提供客户端最适合的资源，内容协商以语言、字符串、编码方式等基准判断资源。
- 常见的首部字段中的判断基准:
  - Accept
  - Accept-Charset
  - Accept-Encoding
  - Accept-Language
  - Content-Language
- 内容协商有3种类型：
  - 服务器驱动协商 Server -driven Negotiation,以服务器端进行内容协商，以请求的首部字段为参考，在服务器端自动处理，但对用户来算根据浏览器发送的信息不一定能筛选出最优内容。
  - 客户端驱动协商 Agent-driven Negotiation，由客户端进行内容协商的方式，用户从浏览器显示的可选项列表手动选择，也可以用JavaScript脚本在Web页面自动进行上述选择，如按OS的类型或浏览器类型自行切换成PC页面或手机页面
  - 透明协商Transport Negotiation，两者相结合。

# 状态码

- 状态码职责是当客户端向服务器发送请求时，描述返回的请求结果，借助它用户可以知道服务器是正常处理了请求还是出现了错误。

- 状态码由3位数字和原因短语组成，如200 OK,数字第一位指定了响应类别，后两位无分类。

  |      | 类别                           | 原因短语                   |
  | ---- | ------------------------------ | -------------------------- |
  | 1XX  | Informtional,信息性状态码      | 接收的请求正在处理         |
  | 2XX  | Success,成功状态码             | 请求正常处理完毕           |
  | 3XX  | Redirection,重定向状态码       | 需要进行附加操作以完成请求 |
  | 4XX  | Client Error,客户端错误状态码  | 服务器无法处理请求         |
  | 5XX  | Server Error，服务器错误状态码 | 服务器处理请求出错         |


### 常用的14种状态码

- 200 OK，表示客户端发来的请求在服务器被正常处理。响应报文中，随状态码返回的信息会因方法不同而改变。如使用GET方法时，对应请求资源的实体会作为响应返回，使用HEAD方法时，响应中只返回首部不返回实体的主体部分。
- 204 No Content,代表服务器接收的请求成功处理，但响应报文不含实体的主体部分，一般在只需客服端往服务器发送信息而服务器不需要对客户端发送更新信息时使用。
- 206 Partal Content，表示客服端进行了范围请求，而服务器成功执行了这部分的GET请求，响应报文包含由Content-Range指定范围的实体范围。
- 301 Moved Permanently,永久重定向。表示请求的资源被分配了新的URI，应该使用新的URI。
- 302 Found，临时性重定向，表示请求的资源分配了新的URI，希望用户本次使用新的URI。
- 303 See Other,表示请求资源有另一个URI，应使用GET方法定向获取请求的资源，与302有相同的功能，但303明确表示客户端应该采用GET方法。
- 301 302 303状态码返回时，几乎所有浏览器都会把POST改为GET，并删除请求报文主体，然后再次发送请求。
- 304 Not Modified,表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件时，直接返回304 Not Modified，304返回时不包含任何响应的主体部分，304虽然划分在3xx类别但和重定向无任何关联。
- 307 Temporary Redirct,临时重定向，与302相同，但尽管302标准禁止POST改为GET，但实际使用时大家不遵守，而307会遵守标准不把POST改为GET。
- 403 Forbidden，表示请求被服务器拒绝，服务器没要必要给出拒绝的详细理由，但如果想做说明的话可以在实体的主体部分给出原因。未获得文件系统的访问授权，访问权限出现某些问题等情况都是403的原因。
- 404 Not Found，表明服务器上找不到请求的资源，在服务器拒绝且不想说明理由时也会404
- 500 Internal Server Error，表明服务器端在执行请求时发送了错误，也可能是Web应用存在的bug和某些临时的故障。
- 503 Service Unavailable,表示服务器暂时处于超负载或正在停机维护，如果事先得知解除此状况需要的时间，最好写入Retry-Afer首部字段在返回给客户端。
- 不少返回的状态码响应都是错误的，比如Web应用程序内部发生错误，状态码仍然返回200 OK

### 单台虚拟主机实现多个域名

- HTTP/1.1允许一台HTTP服务器搭建多个Web站点，如Web托管服务(Web Hosting Service)供应商可用一台服务器为多位客户服务，也可以以每位客户持有的域名运行各自不同的网站，这是因为用了虚拟主机的功能，即使物理层面仅有一台服务器但使用了虚拟主机的功能就可以假想有多台服务器。
- 互联网上域名通过DNS服务映射到IP地址(域名解析)之后访问目标网站，即请求发送到服务器时已经是IP地址的形式，因此若一台服务器托管了www.jd.jp和www.baidu.jp两个域名，收到请求时就需要弄清到底是访问哪个域名。
- 相同IP地址下，虚拟主机可寄存多个不同主机名和域名的Web网站，因此发送HTTP请求时必须在Host首部内完整指定主机名或域名的URI

### 通信数据转发程序：代理、网关、程序

- HTTP通信时除了客户端和服务器还有些用于通行数据转发的应用程序，如代理、网关、隧道，用于配合服务器工作。
- 这些应用程序和服务器能将请求发给下一站服务器然后接收从那台服务器的响应在转发给客户端。

#### 代理：

- 有转发功能的应用程序，扮演客户端和服务器的中间人角色，接收客户端请求转发给服务器，同时也接收服务器返回的响应转发给客户端
- 代理不改变请求URI，直接发送给前方持有资源的目标服务器，持有资源实体的服务器叫源服务器，从源服务器返回的响应经过代理服务器在传给客户端。每次通过代理服务器时都会追加写入Via首部信息以标记经过的主机信息(如Via:proxy1)
- 使用代理服务器理由有:利用缓存技术减少网络带宽流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的等。
- 代理有多种使用方法，以两种基准分类，一是是否使用缓存，二是是否修改报文。
- 缓存代理：代理转发响应时，缓存代理预先将资源副本保存在代理服务器上，当代理再次收到相同资源的请求时直接将缓存资源返回而不经过源服务器。
- 透明代理:转发请求和响应时不对报文做任何加工的代理类型称为透明代理，反之，对报文内容加工的代理称为非透明代理。

#### 网关：

- 转发其他服务器通信数据的服务器，接收从客户端发过来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理，一些客户端甚至不知道其通信目标是网关。
- 网关工作机制和代理相似，但网关能将HTTP请求转化为其他协议通信。
- 利用网关能提高通信安全性，因为可以在客户端和网关之间的通信线路上加密以确保连接安全，比如网关可以连接数据库使用SQL查询数据，也可以在Web购物网站上使用信用卡结算时用网关和信用卡结算系统联动。

#### 隧道：

- 在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。
- 隧道可按要求建立一条与其他服务器的通信线路，届时使用SSL等加密手段通信，隧道目的是确保客户端和服务器进行安全的通信。
- 隧道本身不会解析HTTP请求，即请求保持原样中转给服务器，隧道会在通信双方断开连接时结束。
- 隧道本身是透明的，客户端不用在意隧道的存在。

## 缓存：

- 指代理服务器或客户端本地磁盘保存的资源副本，利用缓存可减少对源服务器的访问也就节省了通信流量和通信时间
- 缓存服务器是代理服务器的一种并归类在缓存代理类型中，当代理转发从服务器返回的响应时代理服务器会保存资源副本。

#### 缓存有效期限：

- 当源服务器资源更新，若使用不变的缓存，就会演变成返回旧资源，因此即使存在缓存也会因为客户端的要求、缓存有效期等因素想源服务器确认资源的有效性，若判断缓存失效，缓存服务器就会再次从源服务器上获取新资源。

#### 客户端的缓存：

- 缓存不仅可存在于缓存服务器中也可存于客户端浏览器中，如IE把客户端缓存称为临时网络文件Temporary Internet File。
- 浏览器缓存若有效，就不必在向服务器请求相同资源，可直接从本地磁盘读取。浏览器缓存也存在有效期。

## HTTP首部

- 报文分为报文首部 空格CR+LF 报文主体，首部内容为客户端和服务器分别处理请求和响应提供所需要的信息，对于客户端来算这些信息中的大部分内容无序亲自查看。

#### 请求报文

- 报文首部由:请求行(包括方法、URI、HTTP版本等)，请求首部字段、通用首部字段、实体首部字段、其他组成

#### 响应报文

- 报文首部由状态行(HTTP版本，状态码)，响应首部字段，通用首部字段，实体首部字段，其他组成



- 报文众多字段中，首部字段包含信息最丰富。
- 使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等。

#### 首部字段结构：

- 首部字段名:字段值       
- HTTP首部以Content-Type这个字段表示报文主体的对象类型，如Content-Type:text/html
- 一个首部字段可以由多个字段值，如Keep-Alive:timeout = 15,max = 100
- 当出现首部字段重复的情况，根据浏览器不同结果可能不一致，一些会优先处理第一次出现的首部字段，一些会优先处理最后出现的首部字段。

#### 4种HTTP首部字段类型

- 通用首部字段 General Header Fields,请求报文和响应报文两方都会使用的首部。
- 请求首部字段 Request Header Fields,从客户端向服务器端发送请求报文使用的首部，补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。
- 响应首部字段Response Header Fields,从服务器端向客户端返回相应报文时使用的首部，补充了响应的附加内容，也会要求客户端附加额外的内容信息
- 实体首部字段Entity Header Fields，针对请求报文和响应报文的实体部分使用的字段，补充了资源内容更新时间等与实体有关的信息。

#### 端到端首部和逐跳首部

- HTTP首部字段将定义成缓存代理和非缓存代理的行为，分为2种类型
- 端到端首部 End-to-end Header:分在此类别中的首部会转发给请求/响应对应的最终接收目标且必须保存在由缓存生成的响应中，且它必须被转发。
- 逐跳首部 Hop-by-hop Header,分在此类别的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1和之后版本若要使用hop-by-hop首部需提供Connection首部字段。
- HTTP/1.1中的逐跳首部字段(除此8个其余都属于端到端首部):
  - Connection
  - Keep-Alive
  - Proxy-Authenticate
  - Proxy-Authorization
  - Trailer
  - TE
  - Transfer-Encoding
  - Upgrade

## HTTP/1.1通用首部字段

#### 1.Cache-Control

- 用于操作缓存
- 指令的参数是可选的，多个指令用逗号分隔，首部字段的Cache-Control指令用于请求及响应时
- eg:Cache-Control:private,max-age=0,no-cache

#### 1.1 表示能否缓存的指令

- public指令，表明其他用户也可利用缓存。
- private指令，响应只以特定用户为对象，缓存服务器对特定用户提供资源缓存服务，其他用户则不返回缓存
- no-cache指令，用于防止从缓存中返回过期的资源。
  - 当客户端请求包含此指令，表示客户端不会接收缓存过的响应，此时中间的缓存服务器必须把客户端请求转发给源服务器。  
  - 当服务器返回的指令包含此指令则缓存服务器不能缓存此资源。
  - 当对no-cache指定参数值，如no-cache=Location(只能在响应指令中指定参数),那么客户端接收到这个指定参数值的首部字段后就不能使用缓存，即无参数首部字段可以缓存

#### 1.2 控制可执行缓存的对象的指令

- no-store指令，暗示请求和对应的响应包含机密信息，使缓存不能在本地存储请求或响应的任一部分。

#### 1.3 指定缓存期限和认证的指令

- s-maxage指令，eg: Cache-Control:s-maxage=6040(单位为s)。功能与max-age相同，它们的不同点是s-maxage指令只适用于供多位用户使用的公共缓存服务器(即代理)，对于向同一用户重复返回响应的服务器来说无效。且使用此指令后会直接忽略对Expires首部字段和max-age的处理。
- max-age指令:用于判定缓存资源的缓存时间，若小于指定时间则客户端就接收缓存资源，当max-age=0，缓存服务器通常需要将请求转发给源服务器。
  - 当服务器返回的响应包括max-age指令，缓存服务器不再对资源有效性进行确认，而max-age数字代表资源保存为缓存的最长时间。
  - HTTP/1.1版本的缓存服务器同时遇到max-age和Expires首部字段，优先处理max-age而忽略掉Expires，HTTP/1.0则恰好相反。
- min-fresh指令，要求缓存服务器返回至少还未过指定时间的缓存资源，eg:Cache-Control:min-fresh=60,表示60秒内若有超过有效期限的资源都无法作为响应返回了。
- max-stale指令，如果指令未指定参数值，那么无论经过多久客户端都会接收响应，若指定了数值,eg:Cache-Control:max-stale=3600,那么即使过期，只要处于指定时间内，客户端仍然接收。
- only-if-cached指令，表示客户端仅在缓存服务器本地缓存目标资源情况下才要求其返回，即该指令要求缓存服务器不重新加载响应，也不确定资源有效性。若无效应返回状态码504 Gateway Timeout
- must-revalidate指令，代理会向服务器再次验证即将返回的响应缓存是否有效，若代理无法连通源服务器再次获取有效资源，缓存必须给客户端一条504 Gateway Timeout状态码。使用此指令时会忽略max-stale指令
- proxy-revalidate指令，要求所有缓存服务器接收到客户端带有该指令的请求返回响应之前必须再次验证缓存有效性。
- no-transform指令，规定无论在请求或响应，缓存都不能改变实体主体的媒体类型，可用于防止缓存或代理压缩图片等。

### 2.Connection

- 控制不再转发给代理的首部字段 eg:Connection:Upgrade,则Upgrade经过代理服务器时被删除
- 管理持久连接，HTTP/1.1版本默认连接是持久连接，当想断开连接时，Connection:close，HTTP/1.1之前版本默认非持久连接，若想持久连接则Connection:Keep-Alive

### 3.Date

- 表明创建HTTP报文的日期时间。
- eg: Date:Tue,03 Jul 2012 04:40:59 GMT

### 4.Pragma

- HTTP/1.1之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义，形式唯一：Pragma:no-cache,该首部字段属于通用首部字段，但只用在客户端发送的请求中，客户端会要求所有中间件服务器不返回缓存的资源。
- 若所有服务器都以HTTP/1.1为基准，直接采用Cache-Control:no-cache，但这不现实，因此发送的请求会同时有两个首部字段:Cache-Control:no-cache    Pragma:no-cache

### 5.Trailer

- 用于事先说明报文主体后记录了哪些首部字段，可应用于HTTP/1.1版本分块传输编码时。

### 6.Transfer-Encoding

- 规定了传输报文主体时采用的编码方式。HTTP/1.1的传输编码方式仅对分块传输编码有效。

### 7.Upgrade

- 用于检测HTTP协议及其他协议是否可用更高版本进行通信，其参数值可用于指定一个完全不同的通信协议。
- eg:Connection:Upgrade   Upgrade:TLS/1.0，Upgrade首部字段产生作用的Upgrade对象仅限于客户端和邻接服务器之间，因此使用Upgrade时需要额外指定Connection:Upgrade
- 对于附有首部字段Upgrade的请求，服务器可用101 Switching Protocol状态码回应。

### 8.Via

- 用于追踪客户端和服务器之间的请求和响应报文的传输路径
- 报文经过代理/网关时会在首部字段Via中附加该服务器的信息再转发，Via不仅用于追踪报文的转发，也可避免请求回环，所以经过代理时必须附加Via
- eg:   Via:1.0 gw.hacker.hp(Squid/3.1)  其中1.0指接收请求的服务器的HTTP版本。
- Via经常与TRACE方法一起用，如代理服务器收到TRACE方法发送的请求(Max-Forwards:0)，代理服务器就不能在转发该请求了，这种情况下代理服务器会将自身信息附加到Via后，返回该请求的响应。

### 9.Warning

- 用于告知用户一些与缓存相关问题的警告
- 格式：Warning:[警告吗] [警告的主机:端口号] ''[警告内容]''([日期时间])

## 请求首部字段

### 1.Accept

- 告知服务器用户代理能处理的媒体类型和媒体类型的相对优先级
- eg:   Accept:text/plain;q=0.3,text/html
- 文本文件:text/html,text/plain,text/css,application/xhtml+xml,application/xml
- 图片文件:image/jpeg,image/gif,image/png
- 视频文件:video/mpeg,video/quicktime
- 应用程序使用的二进制文件:application/octet-stream,application/zip
- 若想给显示的媒体类型增加优先级可以使用q=表示权重值，用分号;分隔，q范围0~1,1为最大值，默认为1，当提供多种内容时，首先返回q最大的。

### 2.Accept-Charset

- 用于通知服务器用户代理支持的字符集及其优先顺序，可指定多种字符集，q表示权重。
- eg:Accept-Charset:iso-8859-5,unicode-1-1;q=0.8

### 3.Accept-Encoding

- 告知服务器用户代理支持的内容编码及其优先级，可指定多种，q表示权重，可用*指定任意编码格式。
- eg:Accept-Encoding:gzip,deflate
- 常见内容编码:
  - gzip:由文件压缩程序gzip生成的编码格式
  - compress，由UNIX文件压缩程序compress生成的编码格式。
  - deflate,组成使用zlib格式和deflate压缩算法生成的编码格式。
  - identify:不执行压缩或不会变化的默认编码格式

### 4.Accept-Language

- 用来告知服务器用户代理能够处理的自然语言集以及自然语言集的相对优先级，可一次性指定多种自然语言集。q表示权重
- eg:Accept-Language:zh-cn,zh;q=0.7,en-us,en;q=0.3

### 5.Authorization

- 告知服务器用户代理的认证信息。通常想通过服务器认证的用户代理接到401状态码后，会把此字段加入请求中。
- eg:Autorization:Basic dWVub3NlbjpwYXNzd29yza==

### 6.Expect

- 告知服务器期望出现的某种特定行为
- eg:Expect:100-continue,等待状态码100响应的客户端发生请求时需指定此指令
- 因服务器无法理解客户端期望作出回应而发生错误时会返回状态码417Expectation Failed

### 7.From

- 告知服务器使用用户代理的用户的邮寄地址。
- eg:From:southsky1999@163.com
- 使用代理时应尽量包含此字段。

### 8.Host

- 由于相同IP地址下回运行多个域名，Host用于明确指出请求的主机名。
- Host首部字段是HTTP/1.1规范内唯一一个必须被包含在请求内的首部字段,若服务器为设定主机名，直接发送空值即可。
- eg:Host:www.hackr.jp

### 9.If-Match

- if-xxx样式的请求首部字段称为条件请求，当服务器接到附带条件的请求时只有判断条件为真时才执行请求。
- eg:If-Match:'123456'，服务器会对比此值和资源的ETag值，二者一致则执行请求否则返回状态码412 Precondition Failed。
- 实体标记ETag:与特定资源关联的却导致，资源更新ETag也会随之更新。

### 10.if-Modified-Since

- 如果在此字段指定的日期后资源更新过，则服务器接受请求。否则返回304 Not Modified
- 获取资源的更新日期时间可用首部字段Last-Modified来确定。

### 11.If-None-Match

- 与If-Match相反，指定值与ETag不一致则服务器处理请求。
- 在GET和HEAD方法中使用此字段可获取最新的资源，与If-Modified-Since类似。

### 12.If-Range

- eg:If-Range:'123456'  Range:bytes=5001-10000
- 告知服务器若指定If-Range值(ETag值或时间)和请求资源的ETag值或时间一致则作为范围请求处理，反之返回全体资源。

### 13.If-Unmodified-Since

- 与if-Modified-Since相反，只有指定的资源在指定日期之后未更新情况下服务器才处理请求，否则返回412 Precondition Failed
- eg:if-UnModified-Since:Thu,03 Jul 2012 00:00:00 GMT

### 14.Max-Forwards

- 通过TRACE或OPTIONS方法发送首部字段Max-Forwards请求时，该字段指定了可经过的服务器的最大数目，每经过一个服务器，Max-Forwards值减1，当服务器接收到值为0时，直接返回响应。
- 用于查找是哪台代理服务器出错了。

### 15.Proxy-Authorization

- 告诉服务器认证所需要的信息。发生在客户端和代理之间

### 16.Range

- 范围请求，成功则返回206 Partial Content，否则返回状态码200 OK和全部资源

### 17.Referer

- 告知服务器请求的原始资源的URI
- eg:Referer:http://www.hacker.jp/index.htm

### 18.TE

- 告知服务器客户端能处理响应的传输编码方式和相对优先级，与Accept-Encoding相似，但用于传输编码。
- eg:TE:gzip。deflate；q=0.5
- TE还可用伴随trailer字段的分块传输编码的方式，TE:trailers

### 19.User-Agent

- 将创建请求的浏览器和用户代理名称等信息传达给服务器
- 由网络爬虫发起请求时可能会在字段内添加爬虫作者的电子邮件地址，且当请求经过代理时，中间也可能被添加上代理服务器的名称。

## 响应首部字段

- 由服务器端想客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息和对客户端的附加要求。

### 1.Accept-Ranges

- 告知客户端服务器能否处理范围请求，可处理则指定byes，否则none

### 2.Age

- 告知客户端源服务器在多久前创建了响应，单位s
- 若创建该响应的服务器是缓存服务器，Age值指缓存后的响应再次发起认证到认证完成的时间值，代理创建响应时必须加上Age

### 3.ETag实体标记

- 将资源以字符串形式做唯一性标识的方式，服务器为每份资源分配对于的ETag值，当资源更新时ETag随之更新，ETag无统一算法规则，仅由服务器分配
- 如使用中英文版的浏览器时二者URI一致，但需要返回各自对应的资源，此时用URI无法判断，就用ETag判断到底返回哪个资源。
- ETag分为强ETag和弱ETag，前者是无论实体变化多么细微都会改值，后者仅用于提示资源是否相同，仅当资源发生根本改变才会该值，此时会在字段值开始处附加W/,如ETag:W/'usagi-1234'

### 4.Location

- 用于和客户端说明URI被转移，该字段会配合3xx:Redirection提供重定向的URI，几乎所有浏览器接收到Location都会强制性的访问新的URI

### 5.Proxy-Authenticate

- 把代理服务器要求的认证信息发给客户端。

### 6.Retry-Afer

- 告知客户端多久后再发送请求，主要配合状态码503 Service Unavailab或3xx Redirect一起。
- 字段值可用是具体日期时间或者创建响应后的秒数

### 7.Server

- 告知客户端当前服务器上安装的HTTP服务器应用程序的信息，包括软件名称、版本号和安装时启用的可选项。
- eg:Server:Apache/2.2.17(Unix)

### 8.Vary

- 控制缓存，如Vary:Accept:Language,代理服务器接收到源服务器的Vary后，若要进行缓存仅能对请求张含有相同Vary指定首部字段的请求返回缓存，否则只能从源服务器重新获取资源。

### 9.WWW-Authenticate

- 用于HTTP访问认证，告知客户端用于访问请求URI指定资源的认证方案(Basic或Digest)和带参数提示的质询(challenge)，状态码401Unauthorized响应肯定包含此字段。
- eg:   WWW-Authenticate:Basic realm=''Usagidesign Auth''

## 实体首部字段

- 包含在请求报文和响应报文中的实体部分所用的首部，包含补充内容的更新时间等信息。

### 1.Allow

- 通知客户端能支持Request-URI指定资源的所有HTTP资源，当服务器接收到不支持的方法返回405 Method Not Allowed且把支持的所有HTTP方法写入首部字段Allow后返回
- eg:Allow:GET,HEAD

### 2.Content-Encoding

- 告知客户端服务器对实体的主体部分选用的内容编码方式，内容编码是在不丢失实体信息前提下进行的压缩
- 常用方式：gizp,compress,deflate,identity

### 3.Content-Language

- g告知客户端实体主体使用的自然语言

### 4.Content-Lenght

- 表明了实体主体部分的大小，进行内容编码时不能使用此字段

### 5.Content-Location

- 给出与报文主体对应URI，与Location不同，Content-Location表示的是报文主体返回资源对应的URI 

### 6.Content-MD5

- 由MD5算法生成的值，目的是检查报文主体传输过程中是否保存完整和确认传输到达。
- 对报文主体执行MD5算法获得128为二进制数，在进行Base64编码后将结果写入此字段(HTTP首部不能记录二进制值所以需要编码)，客户端会再次对报文执行MD5算法，比较即可判断是否完整。
- 此方法无法检测是否被恶意篡改，因为字段值也可以被改变。

### 7.Content-Range

- eg:Content-Range:bytes 5001-10000/10000
- 告知客户端作为响应返回的实体的哪个部分符合范围要求

### 8.Content-Type

- eg:Content-Type:text/html;charset=UTF-8
- 说明实体主体内对象的媒体类型

### 9.Expires

- 将资源失效日期告知客户端
- 缓存服务器接收到包含此字段请求时会以缓存来应答请求，在指定时间前缓存副本一直保存，超出时间后缓存服务器会向源服务器请求资源
- 首部字段Cache-Control的max-age指令优先级高于Expires

### 10.Last-Modified

- 资源最后被修改的时间

# Cookie

- Cookie工作机制是用户识别和状态管理，Web网站为了管理用户状态会通过Web浏览器把数据临时写入用户计算机内，当用户访问网站时可通过通信方式取回之前存放的Cookie
- 调用Cookie时由于可校验Cookie的有效期，发送方的域、路径、协议等信息，因此正规发布的Cookie内的数据不会因攻击而泄露
- 目前为止，Cookie的规格标准文档有4个：
  - 网景公司颁布的规格标准，也是现在的主流标准
  - RFC2109
  - RFC2965
  - RFC6264

### 1.Set-Cookie

- 服务器准备开始管理客户端状态时会事先告知各种信息。
- expires:指定Cookie有效期，不指定则默认为浏览器关闭前，一旦Cookie从服务器发送到客户端，服务器端就不存在显式删除Cookie的方法，但可勇敢覆盖已过期Cookie事先实质性删除
- path:限制指定Cookie的发送范围的文件目录，不过有方法可避开此机制
- domain:通过此属性指定的域名可做到与结尾匹配一致，因此除了针对具体指定的多个域名发送Cookie外，不指定domain显得更安全。
- secure，限制Web页面仅在HTTPS安全连接时才可发送Cookie。eg：Set-Cookie:name=value;secure,省略secure属性时，HTTP和HTTPS都会回收Cookie
- HttpOnly：Cookie扩展功能，使JavaScript脚本无法获得Cookie，目的是防止跨站脚本攻击(Cross-site scripting,XSS)对Cookie信息窃取。eg:Set-Cookie：name=value;HttpOnly,设置此之后，从Web页面可读取Cookie，但从JS的document.cookie读取Cookie，但此扩展并非为了防止XSS而开发。

## 2.Cookie

- 告知服务器当客户端向获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie，接收到多个Cookie时同样以多个Cookie形式发送

## 其他首部字段

- HTTP首部字段可自行扩展，以下是常用的非标准首部字段

### 1.X-Frame-Options

- eg:X-Frame-Options:DENY
- 属于HTTP响应首部，用于控制网站内容在其他Web网站的Frame标签内的显示问题，目的是防止点击劫持攻击
- 此字段有2个可指定的字段值:DENY,拒绝     SAMEORIGIN,仅同源域名下的页面匹配时许可。

### 2.X-XSS-Protection

- 属于HTTP响应首部，针对跨站攻击XSS的对策，用于控制浏览器XSS防护机制的开关。
- 可指定字段值:0，将XSS过滤无效化。1：xss过滤有效状态。

### 3.DNT

- HTTP请求首部，Do Not Track，拒绝个人信息被收集，是拒绝精准广告追踪的方法。
- 可指定字段值   1：拒绝追踪  0：统一追踪

### 4.P3P

- 属于HTTP响应首部，利用P3P(The Platform for Privacy Preferences,在线隐私偏好平台)技术让Web平台上的个人隐私变成仅供程序可理解的形式从而保护隐私
- 步骤：1.创建P3P隐私 2.创建P3P隐私对照文件后，保存命名在/w3c/p3p.xml   3.从P3P隐私新建Compact policies后输出到HTTP响应中。

## HTTP缺点

- 通信使用明文，内容可能被窃听
- 不验证通信方身份，有可能遭遇伪装
- 无法证明报文完整性，可能遭到篡改

#### 加密处理防止被窃听

- 方式1：通信加密，HTTP协议无加密机制，但可以通过和SSL(Secure Socket Layer,安全套接层)或TLS(Transport Layer Security,安全传输层协议)的组合使用加密通信，用SSL建立安全通信线路后就可以进行HTTP通信了，与SSL组合使用的HTTP称为HTTPS(HTTP Secure,超文本传输安全协议)或HTTP over SSL。
- 方式2:内容加密，对HTTP报文进行加密处理，这要求客户端和服务器同时具备加密和解密机制，不同于SSL和TLS整个通信线路被加密处理，内容仍然有被篡改的风险。

#### 不验证身份，遭遇伪装

- HTTP协议的事先本身十分简单，不论是谁发送的请求都会响应，因此无法确认通信方。
- 通过SSL的证书可以确定通信方，证书由值得信任的第三方机构颁发，用于证明服务器和客户端是实际存在的，且伪造证书十分困难。通过使用证书确认通信方就是意料中的服务器，对使用者来说减少了个人信息泄露的危险性，且客户端持有证书即可完成个人身份的确认，也可用于Web网站的认证环节。

#### 无法验证报文完整性，可能被篡改

- 请求和响应在传输途中遭攻击者拦截且篡改内容的攻击称为中间人攻击MITM,Man-in-the-Middle attack
- 常用方法是MD5和SHA-1等散列值校验的方法和用来确认文件的数字签名方法，提供文件下载的网站也会提供相应PGP(Pretty Good Privacy，完美隐私)创建的数字签名及MD5算法生成的散列值。但无论哪种方法都需用户本人亲自检查验证下载的文件是否是原本服务器上的文件，浏览器无法自动帮用户检查。
- 这些方法无法百分百保证结果正确，因为PGP和MD5本身也可被改写，因此仅靠HTTP自身不行，需要使用HTTPS

### HTTP+加密+认证+完整性保护=HTTPS

- 经常在Web登录页面和购物结算页面使用HTTPS通信，此时不再是http://，而是https://，浏览器地址栏会出现一个锁。
- HTTPS不是新协议，只是HTTP通信接口部分用SSL和TLS协议代替。SSL是独立于HTTP的协议，其他应用层的SMTP、Telnet等协议均可配合SSL协议使用，SSL是世界上应用最广泛的网络安全技术。

### 公开密钥加密技术

- 近代加密方法中加密算法是公开的，密钥却是保密的，通过这种方式保持加密方法的安全性。
- 加密和解密用用一个密钥的方式称为共享密钥加密(Common key crypto system)，但此方法必须把密钥也发给对方，发送过程可以被监听，所以得设法安全得保管接收到的密钥。
- 公开密钥加密方式解决了共享密钥加密的困难，公开密钥加密使用一对非对称的密钥，私有密钥和公开密钥，发送密文的一方使用对方的公开密钥进行加密处理，对方收到加密信息后再使用自己的私有密钥进行解密，利用这种方法不需要发送私有密钥，即不必担心密钥被攻击者窃听而盗走。
- 根据密文和公开密钥恢复到原文是异常苦难的，解密相对于对离散对数求值，如果能对非常大的整数做到快速因式分解，就有希望破解密钥，但目前技术来看不现实。
- 由于公开密钥加密技术效率低于共享密钥加密，因此HTTPS使用二者并用的混合加密机制，再交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段使用共享密钥加密方式。

### 证明公开密钥正确性的证书

- 由于无法证明公开密钥的真实性，即公开密钥可能运输途中被攻击者替换掉，所以需要使用数字认证机构和相关机构颁发的公开密钥证书，由于认证机关的公开密钥必须安全的转交给客户端，但安全转交十分苦难，因此多数浏览器开发商发布版本时会事先在内部植入常用认证机关的公开密钥。

### EV SSL证书

- 证书的一个作用是证明通信以方的服务器是否规范，另一个作用是确认对方服务器背后运营的企业是否真实存在，EV SSL证书即有该功能。
- 拥有EV SSL证书的网站地址栏背景色是绿色，且地址栏左侧显示了SSL证书中记录的组织名称及颁发证书的认证机构的名称



### SSL速度

- SSL的慢分两种，通信慢与由于大量消耗CPU及内存等资源导致处理速度变慢。
- 针对速度变慢，无根本解决方案，可使用SSL加速器硬件来改善该问题，此加速器仅在SSL处理时发挥作用以分担负载。

## 认证

- 计算机为了确认计算机使用者的身份，需要核对一下信息
  - 密码：本人才知道的字符串信息
  - 动态令牌：仅限本人持有的设备内显示的一次性密码
  - 数字证书：仅限本人(终端)持有的信息
  - 生物认证:指纹虹膜等生理信息
  - IC卡:仅本人持有的信息。
- 由于即使为假冒用户，只要通过了验证，计算机就会默认是本人，因此掌控机密信息的面绝不能让他人得到，更不能轻易被破解
- HTTP/1.1常用认证方式
  - BASIC认证，基本认证
  - DIGEST认证，摘要认证
  - SSL客户端认证
  - FormBase认证，基于表单认证

#### BASIC认证

- 从HTTP/1.0就定义的认证方式，采用Base64编码方式，由于非加密处理，被盗可能性极高，且想再次进行BASIC认证时，一般浏览器无法实现认证注销操作，因此不常用

#### DIGEST认证

- HTTP/1.1起开始有此认证，使用质询/响应(challenge/response)的方式，质询响应指一开始一方先发送认证要求给另一方，接着从另一方那收到的质询码计算生成响应码，最后响应码返回给对方进行认证的方式，相比BASIC，安全性提高。

#### SSL认证

- 当用户id和密码被盗很可能被第三方冒充，SSL客户端认证即可避免该情况发生，它借由HTTPS的客户端证书完成认证，凭客户端证书服务器可确认访问是否是自己登录的客户端。
- ![image-20211024130432387](http://r19kczb6x.hn-bkt.clouddn.com/img/image-20211024130432387.png)

- 多数情况SSL客户端采用双因素认证，Two-factor authentication,同时使用证书认证和基于表单认证，即两个认证因素分别是SSL客户端证书、认证因素的密码。

#### 基于表单认证

- 客户端向服务器的Web应用程序发生登录信息，根据Web应用程序不同提供的用户解密和认证方式也各不相同(类似各种app登录，可以用微信，微博，邮箱手机号等)
- 由于BASIC、DIGEST认证安全性不足，SSL客户端认证需要维持费用，因此认证多半为基于表单认证。

## SPDY

- Google2010年发布了SPDY(SPeeDY，发音同speedy)，开发目标是解决HTTP性能瓶颈，缩短Web页面加载时间。
- 若想在现有Web实现所需功能，以下HTTP标准会成为瓶颈:
  - 一条连接上只可发送一个请求
  - 请求只能从客户端开始，客户端不可接收除响应以外的指令
  - 请求/响应首部未经压缩就发送，首部信息越多延迟越大
  - 发送冗长的首部，每次互相发送相同的首部造成的浪费较多
  - 可任意选择数据压缩格式，非强制压缩方式。

#### 1.Ajax

- Ajax(Asynchronous JavaScript and XML,异步JavaScript与XML技术)是一种有效利用JavaScript和DOM(Document Object Model,文档对象类型)的操作，以达到局部Web页面替换加载的异步通信手段，与以前同步通信相比它只更新一部分页面，响应中传输的数据量因此而减少
- Ajax核心技术是名为XMLHttpRequest的API，通过JS语言的调用就能和服务器进行HTTP通信，借此方法就能从加载完毕的Web页面上发起请求，只更新局部页面
- 但Ajax实时地从服务器获取内容，有可能导致大量请求产生，且Ajax未解决HTTP协议本身存在的问题。

#### 2.Comet

- 通常服务器端接收到请求在处理完毕后会立即返回相应，但为了实现推送功能，Comet会先将响应置于挂起状态，当服务器内容更新时在返回相应，达到服务器端一旦更新就立即反馈给客户端的效果，这是一种通过延迟应答，模拟实现服务器端向客户端推送(Server Push)的功能
- 内容虽可以实时更新，但为了保留响应，连接的持续时间也加长，期间为了维持连接会消耗更多的资源，且Comet也未解决HTTP协议本身存在的问题。

#### 3.SPDY的目标

- SPDY未完全改写HTTP协议，而是在TCP/IP的应用层和传输层之间通过新加会话层的形式运作，同时规定通信中使用SSL。
- 使用SPDY获得的额外功能:
  - 多路复用流:通过单一的TCP连接可以无限制处理多个HTTP请求，所有请求在一条TCP连接上处理，TCP处理效率得以提高。
  - 赋予请求优先级:SPDY不仅可以无限制的并发处理请求且可以给请求逐个分配优先级顺序从而解决因带宽低而导致响应变慢的问题
  - 压缩HTTP首部:达到通信产生的数据包数量和发送的字节数减少的效果
  - 推送功能:支持服务器主动向客户端推送数据的功能而不必等待客户带请求。
  - 服务器提示功能:服务器可主动提示客户带请求所需资源从而避免不必要请求。

#### 4.SPDY效果

- 由于SPDY基本上只是将单个域名的通信多路复用，因此当一个Web网站上使用多个域名下的资源，改善效果就被限制
- SPDY一定程度上消除了HTTP瓶颈。

## WebSocket

- 即Web浏览器和Web服务器之间全双工通信标准，是为了彻底解决HTTP瓶颈问题而开发的一套全新协议和API

- 设计与功能:一旦Web服务器和客户端建立起WebSocket协议的通信连接，之后所有通信都依靠这个协议进行，通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据，连接发起方是客户端，一旦确立是WebSocket通信连接，服务器和客户端任意一方都可直接向对方发送报文。

- #### WebSocket特点

  - 推送功能:支持服务器向客户端推送数据
  - 减少通信量:只要建立起WebSocket连接就希望一种保持连接状态，这样不但每次连接时总开销减少且WebSocket首部信息很小，通信量也响应减少。为了实现WebSocket通信，在HTTP连接建立后，需要完成一次握手(handshaking)步骤。

- 握手请求:为实现WebSocket请求，需要用到HTTP的Upgrade首部字段告知服务器通信协议改变，达到握手的目的.

- ```http
  #握手请求
  GET/chat HTTP/1.1
  Upgrade:websocket                            #告知协议改变
  Connection:Upgrade
  Sec-WebSocket-Key:dGhlIHNhbXBsZSBub25jZQ==   #记录握手过程中必不可少的键值
  Origin:http://example.com
  Sec-WebSocket-Protocol:chat,superchat        #记录使用的子协议
  Sec-WebSocket-Version:13
  
  #握手响应
  HTTP/1.1 101 Switching Protocol                          #响应请求
  Upgrade:websocket
  Connection:Upgrade
  Sec-Websocket-Accept:s3pPLMBiTxaQ9kYGzzhZRbK+xo0=        #此字段值由握手请求中的key值生成
  Sec=WebSocket-Protocol:chat
  ```

- 成功连接后不再使用HTTP数据帧，而采用WebSocket独立的数据帧

- JS可调用‘’The WebSocket API''内提供的WebSocket程序接口实现WebSocket协议下全双工通信。

## Web应用

- 只通过Web功能提供的应用程序，如购物网站、网上银行等，由程序创建的内容成为动态内容，而事先准备好的内容成为静态内容，Web应用作用于动态内容上。

#### 与Web服务器及程序协作的CGI

- CGI(Common Gateway Interface,通用网关接口)指Web服务器接收到客户端发送过来的请求后转发给程序的一组机制，在CGI作用下程序会对请求内容做出相应动作，如创建HTML等动态内容。使用CGI的程序叫CGI程序，通常用Perl、PHP、Ruby和C等语言写成。

#### 因Java而普及的Servlet

- Servlet是能在服务器上创建动态内容的程序，是用Java语言实现的一个接口，属于面向企业级Java的一部分。CGI每次收到请求程序都要跟着启动一次，一旦访问量过大Web服务器就要承担相当大的负载，而Servlet运行在与Web服务器相同进程中因此收到负载较小，Servlet运行环境叫Web容器或Servlet容器。

#### 发布更新信息的RSS/Atom

- RSS(简易信息聚合，也叫聚合内容)和Atom都是发布新闻或博客日志等更新信息文档的格式的总称，二者都用到了XML

#### JavaSricpt衍生的轻量级应用JSON

- JSON(JavaScript Object Notation)是一种以js的对象表示法未基础的轻量级数据标记语言，能处理false/null/true/对象/数组/数字/字符串 这7种类型
- JSON让数据更纯粹且JSON字符串可被JS轻易读入。

## Web攻击技术

- 
