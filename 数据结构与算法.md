# 数据结构与算法  听课时把代码敲一遍

#### 图灵机组成：

- 一条无限长的分格纸带，每格可以记录一个符号
- 一个读写头，可在纸带上左右移动，能读出和擦写格子的字符
- 一个状态寄存器，记录有限状态中的1个状态
- 一系列的控制规则：(五元组)
  - 某个状态，读入某个字符时
  - 要改写成什么字符
  - 如何移动读写头
  - 要改变什么状态

#### 计算资源：

- 算法解决问题过程中需要的存储空间或内存
- 算法的执行时间 

问题规模：影响算法执行时间

## 大O表示法：

数量级函数描述了T(n)中随着n增加而增加速度最快的主导部分。

对算法的分析看主流，即平均状况

常见大O数量级函数：

- 常数1
- 对数log(n)
- 线性 n
- 对数线性 n*log(n)
- 平方 n^2
- 立法 n^3
- 指数 2^n

![image-20211008145859433](C:\Users\south\AppData\Roaming\Typora\typora-user-images\image-20211008145859433.png)

- 双重循环：n^2
- 单层循环：n
- 仅保留最高项 so T(n^2)

变位词：两个词之间存在字母的重新排列关系

排序算法数量级大部分都是O(n logn )

n个字符全排列，所有可能字符串个数为n!

### Python数据类型的性能

![image-20211008153924069](C:\Users\south\AppData\Roaming\Typora\typora-user-images\image-20211008153924069.png)

``` 
List列表数据类型常用操作性能：
按照索引取值与赋值： V = a[i]  a[i] = v  由于列表的随机访问特性，这两个操作时间与列表大小无关，都是O(1)
列表增长：append() 执行时间是o(1)   _add_()  list = list + [v] 执行时间是O(n+k)是y
```

![image-20211008163309166](C:\Users\south\AppData\Roaming\Typora\typora-user-images\image-20211008163309166.png)

pop()  列表末尾移除元素，O(1)

pop(i)列表中移除元素，O(n)



input.spilt()：单行输入多个变量，用此函数读入并分解为列表

list(map(int,input().split))：多个整数在一行，用此函数获取

### 线性结构：

- 一种有序数据项的集合，每个数据项有唯一的前驱和后继。(除了首尾)
- 新的数据项只能加入到原有的某个数据项之前后之后
- 关键在于元素插入方式，有些只能从前，有些只能从后面，有些可以从中间或两端。

#### 前prefix，中infix，后缀postfix表达式

![image-20211009141242547](C:\Users\south\AppData\Roaming\Typora\typora-user-images\image-20211009141242547.png)



前缀和后缀表达式中，操作符的次序完全决定了运算次序。

![image-20211009141437797](C:\Users\south\AppData\Roaming\Typora\typora-user-images\image-20211009141437797.png)

++A*BCD：首先离操作数最近的是 *,so B * C,然后是+,距离A最近，so +A，最后是D so +D

ABC*+D+:距离操作数最近的是  * so B*C ,在与A、D相加

前缀从前往后看，后缀从后往前看   操作符只作用于最近的两个操作数

无论表达式多复杂，转换成前缀或后缀，只需两个步骤：

1. 中缀表达式转换为全括号形式
2. 将所有操作符移动到子表达式所在的左括号(前缀)或右括号(后缀)处，替代之，再删除所有括号。

中缀表达式转换成后缀形式过程中操作符比操作数晚输出且由于优先级规则，操作符可能要反转次序输出，这种反转特性使得我们考虑用栈来保存暂时未处理的操作符。  栈顶的操作符就是最近暂存进去的，遇到新操作符，需要和栈顶比较优先级再处理。

## 队列Queue

- 新数据项的添加总发生再尾端 rear 端
- 现存数据项的移除总发生再首端 front端
- 先进先出 first in first out fifo
- 键盘缓冲区，进程队列都是典型的队列

热土豆问题(约瑟夫问题)：约瑟夫和39人准备殉难，坐成一圈，报数1~7，报7的人由旁边的人杀死，约瑟夫活了下来。

打印任务模拟

## 双端队列Dueue

类似队列，可以队尾或队首加入。不能从中间加入

eg：判断回文词

##  链表

#### 无序列表UnorderedList

- 数据项存放位置并没有规则，但如果数据项之间建立链接指向，就可以保存其前后相对位置
- 第一个和最后一个数据项需要显式标记
- 链表最基本元素是节点Node 每个节点至少包含2个信息：数据项本身以及指向下一个节点的引用信息next
- 第一个和最后一个节点最重要
- 判断空表的isEmpty()很容易实现，只需检查head
- 添加新数据项最快捷位置是表头，所以从表头添加

#### 有序列表 OrderedList

- 依照某可比性质决定列表位置
- add()与search()方法与无需表有所差别
- Python内置的列表数据是基于顺序存储来实现

# 递归 recursion

将问题分解为规模更小的相同问题。

明显特征是在算法流程中调用自身

```
def addlist(numlist):
    if len(numlist) == 1:
        return numlist[0]
    else:
        return numlist[0]+addlist(numlist[1:])

print(addlist([1,3,5]))
```

### 递归三定律

- 必须有基本结束条件(最小规模问题直接解决)
- 递归算法必须能改变状态向基本结束条件演进。
- 递归算法必须调用自身

```python
#递归在进制转换的引用
def toStr(n,base):
    '''整数转换为任意进制'''
    convertString = '0123456789ABCDEF'
    if n<base:
        return convertString[n]
    else:
        return toStr(n//base,base)+convertString[n%base]
```

- 当一个函数被调用时，系统会把调用时的现场数据压入到系统调用栈
- 每次调用，压入栈的现场数据称为栈帧
- 函数返回时，要从调用栈的栈顶取得返回地址，恢复线程，弹出栈帧，按地址返回

- 递归时常碰到的错误:RecursionError  2个原因：1.忘记设置基本结束条件 2.算法不好，超出调用深度限制 
- sys.getrecursionlimit 查看最多递归次数 sys.getrecursionlimit,修改最大递归次数
- 递归可视化:分叉树，谢尔宾斯基三角形，汉诺塔问题，探索迷宫

贪心策略：硬币找零

#### 递归解法：找零兑换

```python
def recMC(coinValueList,change):
    #coinValueList 硬币体系
    # change:需要找零的钱数，如需要找零63美元
    minCoins = change
    if change in coinValueList:
        return 1
    else:
        for i in [c for c in coinValueList if c<= change]:
            #如11分钱，首先减去1分硬币，剩下十分钱最优解是1
            #再减去5分硬币，剩下6分钱最优解是2
            #再减去10分钱，剩下1分钱最优解是1
            #通过遍历每一个面值，找出所最优解是2，
            numCoins = 1+recMC(coinValueList,change-i)
            if numCoins < minCoins:
                minCoins = numCoins
    return minCoins
print(recMC([1,2],7))
```

#### 动态规划解法：

- 采用了一种更有条理的方式求解
- 从最简单的一分钱找零的最优解开始，逐步递加
- 递加过程设法保持每一分钱递加都是最优解

### 递归总结

- 某些情况下，递归可以代替迭代循环
- 递归算法通常能和问题的表达自然契合
- 递归不总是合适的算法，有时会引发巨量的重复计算
- 记忆化/函数值缓存能提供附加存储空间记录中间计算结果来有效减少重复值
- 如果一个问题最优解包括规模更小相同问题的最优解，就可以用动态规划来解决

### 顺序查找

通过下标按照顺序来访问和查找数据项，称为顺序查找。

- 复杂度O(n)

### 二分查找

- 从列表中间开始查找，如果中间项>查找项，查找项只可能出现在前半部分，也就是查找范围减半。

- 作用于有序表
- 体现了解决问题的典型策略：分而治之 
- 无论数据项是否匹配，当n/(2^i) = 1时，循环都会结束，因此二分查找的复杂度是 i =log2(n)  即 O(log n)

```python
切片的操作复杂度是O(k)
常规版本：
def binarySearch(alist,item):
    first = 0
    last = len(alist)-1
    found = False
    while first <= last and not found:
        midpoint = (first + last)//2
        if alist[midpoint] == item:
            found = True
        else:
            if item < alist[midpoint]:
                last = midpoint - 1
            else:
                first = midpoint + 1
        return found
递归版本：
def binarySearch(alist,item):
    if len(alist) == 0:
        return False
    else:
        midponit = len(alist)//2
        if alist[midponit] == item:
            return True
        else:
            if item < alist[midponit]:
                return binarySearch(alist[:midponit],item)
            else:
                return binarySearch(alist[midponit+1:],item)
```

### 冒泡排序Bubble Sort

-  算法思路在于对无序表进行多趟比较交换
- 每趟包括了多次两两相邻比较，将逆序数据项交换位置，最终将最大项就位
- 经过n-1趟比较交换实现整表排序
- 每趟过程类似于气泡再水中上升浮到水面的经过。
- 第1趟比较交换，共n-1对相邻数据比较
- 第2趟比较交换，最大项已就位，需要排序的数据减少为n-1,共n-2对相邻数据比较
- 直到n-1趟完成后，最小项一定再列表首位，无需处理
- 随着趟数的增加，比对次数由n-1逐步减少到1，因此比对次数是(n^2)/2  -  n/2,复杂度是O(n^2)
- 效率差，大部分比对无效，优点是无额外存储空间开销。

```python
def bubbleSort(alist):
def bubbleSort(alist):
    for passnum in range(len(alist)-1,0,-1):   #趟数：n-1趟
        for i in range(passnum):
            if alist[i] > alist[i+1]:
                alist[i],alist[i+1] = alist[i+1],alist[i]
```

### 插入排序

- 复杂度O(n^2)
- n-1趟比对和插入，比对用于寻找新项的插入位置
- 由于移动操作仅包含1次赋值，是交换操作的1/3,所以插入排序性能稍好

```python
def insertionSort(alist):
    for index in range(1,len(alist)):
        currentvalue = alist[index]  #插入项
        position = index
        while position > 0 and alist[position - 1] > currentvalue:
            alist[position] = alist[position-1]
            position = position - 1
        alist[position] = currentvalue
```

### 谢尔排序

- 以插入排序为基础，对无序表进行间隔划分子列表，每个子列表执行插入排序。
- 随子列表数量减少，无序表越来越接近有序，从而减少整体排序的次数
- 间隔为3的子列表，子列表分别插入排序后的整体情况更接近有序  
- 复杂度O(n^(3/2))

### 归并排序

- 将数据表持续分裂为两半，对两半分别进行归并排序
- 基本结束条件：数据表仅有1个数据项
- 缩小规模：数据表分裂为相等的两半
- 调用自身：将列表分别调用自身排序，然后将分别排好序的两半归并，得到排好序的数据表
- 分裂过程：借鉴二分查找，是对数复杂度,O(log n)
- 归并过程:相对于分裂的每个部分，其所有数据项都会被比较和放置一次，所以是线性复杂度，O(n)
- 总复杂度：O(nlog n)
- 归并排序使用了额外1倍存储空间用于归并

### 快速排序

- 依据一个中值数据项把数据表分为两半：小于中值的一半和大于中值的一半，每部分分别快速排序
- 通常选用第一个值，降低复杂度
- 快速排序的递归三要素
  - 基本结束条件:数据表仅有1个数据项，自然是排好序的
  - 缩小规模:根据中值将数据表分为两半，最好情况是相等规模的两半
  - 调用自身:将两半分别调用自身进行排序
- 分裂数据表的目标:找到中值位置
- 分裂数据表手段：设置左右标，左标向右，碰到比中值大的就停止，右标相反，然后把左右标所指的数据项交换。直到左标移动到右标的右侧，这时右标所指位置就是中值应处位置，将中值与这个位置交换，分裂完成，左半部小于中值，右半部大于中值。
- 快速排序分为 分裂和移动两部分  分裂：O(log n)   移动(每项与中值相比):O(n)  总的就是O(nlog n )
- 不需要额外存储空间
- 极端情况，当有一份始终无数据，时间复杂度会退化到O(n^2),有时可以适当改进中值选择方法，如从数据表的头尾中间取出中值

## 散列(hash table，又叫哈希表)

- 一种数据集，其中数据项的存储方式尤其有利于快速查找定位。
- 散列表中每一个存储位置称为槽，用来保存数据项，每个槽有一个唯一的名称
- 实现从数据项到存储槽名称的转换的，叫散列函数。
- 常用散列方法：求余数
- 槽被数据项占据的比例称为散列表的负载因子
- 数据项保存到散列表后，要查找某个数据项只需使用同一个散列函数对查找项进行计算，测试返回的槽号所对应的槽中是否有数据项即可，复杂度为O(1)
- 冲突，collusion,散列函数中最重要的问题
- 完美散列函数:给定一组数据项，如果一个散列函数能把每个数据项映射到不同的槽中，这个散列函数就叫完美散列函数
- 好的散列函数特性：
  - 冲突最少(近似完美)
  - 计算难度低：额外开销小
  - 充分分散数据项：节约空间
- 著名散列函数:MD5/SHA    pythonz自带的散列函数库hashlib包括md5,sha1,sha224,sha256,sha384,sha512六种散列函数

```python
import hashlib
m = hashlib.md5()   #使用MD5函数
m.update(b'dddd')    #update()功能是对任意长数据部分进行计算  且只接收byte类型字符串， 不接收str
print(m.hexdigest())   #hexdigest() 返回16进制字符串数值  digest()返回二进制字符串数值
```

- 完美散列函数作用于数据一致性校验:
  - 数据文件一致性判断
  - 为每个文件计算其散列值，仅对比其散列值即可得知文件内容是否相同
  - 用于网络文件下载完整性校验
  - 用于文件分享系统，网盘中相同文件无需存储多次
  - 加密形式保存密码:仅保存散列值
  - 防文件篡改，原理同数据文件一致性判断

# 区块链：散列函数最酷的应用

- 区块链是一种分布式数据库，通过网络连接的 每个节点都保存着整个数据库所有数据，任何地点存入的数据都会完成同步。 

- 区块链最本质特征：去中心化，即不存在任何控制中心，协调中心节点。所有节点都是平等的，无法被控制
-  区块链由一个个区块(block)构成，区块分为头head和体body
- head记录了一些元数据和链接到前一个区块的信息(生成时间，前一个区块head+body的散列值)，body记录了实际数据
- 区块链具有不可修改性:由于散列值具有抗修改性，任何对某个区块数据的改动必将引起散列值的变化。为了不导致这个区块脱离链条，就需要修改所有后续区块。由于有工作量证明的机制，这种大规模修改是不可能实现的，除非掌握了全网51%以上的计算力。
- 工作量证明机制:Proff of Work POW:
  - 由于区块链是大规模的分布式数据库，同步较慢，新区块的添加速度需要得到控制。
  - 目前最大规模区块链Bitcoin是平均每10分钟生成一个区块。
  - 大家不惜付出海量的计算去抢着算出一个区块的有效散列值，最先算出的那位矿工才有资格把区块挂到区块链中。
- 为什么有效散列值难以计算:
  - 因为很难算出，所以控制了新区块的生成速度，便于在整个分布式网络中同步。
  - 每个区块设置了一个难度系数Difficulty，用常数targetmax除以它，得到一个target,难度系数越高，target越小。
- 矿工的工作：
  - 找到一个数值Nonce,把它和整个区块数据一起计算散列，这个散列值必须小于target才是有效的散列值。
  - 由于散列值无法回推原值，这个Nonce的寻找只能暴力穷举，计算工作量+运气是唯一方法。
- 为什么矿工抢着生成区块:
  - 加密货币Bitcoin中，区块包含的数据是交易记录即账本，这对货币体系至关重要
  - Bitcoin规定每个区块包含了一定数量的比特币作为记账奖励，这样就鼓励更多人加入到抢先记账的行列。
  - 由于硬件摩尔定律的存在，计算力将递增，为了维持每10分钟生成一个区块的速度，难度系数Diffculty也持续递增。
  - 为了保持货币总量不会无限增加，每四年奖励的比特币减半。

### 散列函数设计

### 1.折叠法

- 将数据项按照位数分成若干段，再将几段数字相加，最后对散列表大小求余得到散列值。

- eg:电话号码62767255 分为62  76  72  55  相加=265,散列表包括11个槽，265%11 =1  so h(62767255)=1

- 有时折叠法包括一个隔数反转的步骤  62 76 72 55中 76和55反转  62+67+72+55 = 256,256%11=3，so 

  h(62767255) = 3，隔数反转为散列函数提供了一种微调手段以便更好地符合散列特性。

### 2.平方取中法

- 将数据项做平方运算，然后取平方数的中间两位，在对散列表大小求余   计算机稍大
- eg:对44进行散列 44^2 = 1936  93%11 = 5,h(44)=5

#### 非数项散列函数设计

- 把每个字符看作ASCII码再累加，最后对散列表大小求余。
- 对于变位词，可以将字符串所在位置作为权重因子，乘以ord值(cat的ASCII值)

### 散列冲突解决方案：

### 1.开放定址

- 解决散列是一种方法是为冲突的数据项再找一个开放的空槽来保存。最简单的就是从从冲突槽往后开始扫描，直到碰到一个空槽，如果尾部未找到，则从首部开始扫描
- 寻找空槽的技术称为 开放定址，open addressing
- 往后逐个槽寻找的方法是开放定址技术中的线性探测linear probing
- 散列表的查找与解决冲突方法需要遵循相同规则
- 线性探测法的缺点:聚集趋势，如果冲突较多，数据项会在槽附近聚集从而连锁式影响其他数据项插入。
- 线性探测的改进:跳跃式探测。如+3式探测。

#### 再散列rehashing

- 重新寻找空槽用再散列:rehashing来概括:newhashvalue = rehash(oldhashvalue),对于线性探测来说，rehash(pos) = (pos+1)%sizeoftable    +3式探测:rehash(pos) = (pos+3)%sizeoftable  注意跳跃式探测的skip取值不能被散列表大小整除，否则会导致 很多空槽永远无法被探测到。因此可以把散列表大小设为素数，无法被整数
-  还可以将线性探测变成二次探测，逐步增加skip值，1 3 5 7 9

### 2.数据项链 chaining

- 将容纳单个数据项的槽扩展为容纳数据项集合。这样每个槽可以容纳多个数据项。
- 查找数据项时需要查找同一个槽中的整个集合，查找时间增加。

### 映射抽射数据类型:ADT Map

- python中的字典，保存key-data键值对数据类型，这种键值关联的方法称为映射MAP
- ADT Map的结构是键值关联的无序集合，关键怕具有唯一性，通过关键码确定唯一数值
- 用HashTable类来实现ADT Map，该类包含了两个列表作为成员:slot列表用于保存key，data列表保存数据项。在slot列表找到一个key的位置后，在data列表对应相同位置的数据项即为关联数据。
- 保存key的列表就作为散列表来处理，这样可以迅速找到指定的key，散列表大小选择素数

### 散列算法分析

- 最好情况下，提供O(1)常数级时间复杂度
- 评估散列冲突最重要信息就是负载因子lambda，负载因子较小，散列冲突几率就小，数据项通常保存在其所属的散列槽中。负载因子较大，表示散列表填充较满，冲突会越来越多，冲突解决也复杂。
- 开放定址法：lambda 0~1      数据链：lambda可大于1

# 排序与查找小结

- 在无序表或有序表上的顺序查找，时间复杂度为O(n)
- 有序表上二分查找，最差复杂度为O(log n)
- 散列表可以实现常数级时间的查找
- 完美散列函数作为数据一致性校验，应用很广
- 区块链技术是一种去中心化的分布式数据库，通过工作量证明机制来维持运行
- 冒泡、选择、插入排序复杂度为O(n^2)
- 谢尔排序在插入排序基础上进行了改进，采用对递增子表排序的方法，其时间复杂度O(n)~O(n^2)
- 归并排序时间复杂度是O(nlog n),但归并过程需要额外存储空间
- 快速排序最好时间复杂度是O(nlog n),也不需要额外存储空间，但如果分裂点偏离列表中心，会退化为O(n^2)

# 树

- 非线性结构，是一种分层结构，越接近顶部的越普遍，越接近底部的越独特 
- 一个节点的子节点与另一个节点的子节点之间是隔离，独立的
- 每一个叶节点具有唯一性

### 树的结构

- 节点Node：组成树的基本部分，每个节点具有名称(键值)，节点可以保存额外数据项，数据项根据不同应用而变
- 边Edge：组成树的另一个基本部分，每条边恰好连接2个节点，表示节点之间具有关联，边具有出入方向，每个节点(除根节点)恰有一条来自另一节点的入边，每个节点可以有多条连到其他节点的出边。
- 根Root:树中唯一没有入边的节点
- 路径Path：由边一次连接在一起的节点的有序列表
- 子节点Children：入边均来自同一个节点的若干节点称为这个节点的子节点
- 父节点Parent：一个节点是其所有出边所连接节点的父节点
- 兄弟节点Sibling：具有同一个父节点的节点
- 子树Subtree:一个节点与其所有子孙节点以及相关边的集合
- 叶节点Leaf:没有子节点的节点
- 层级Level：从根节点开始到达一个节点的路径，所包含的边的数量称为层级。
- 高度：树中所有节点的最大层级。 

### 树的定义

1. 树是由若干节点以及两两连接的边组成。如果每个节点最多有两个子节点，称为二叉树
2. 递归定义：空集或由根节点及0或多个子树构成，每个子树的根到根节点具有边相连。

#### 树的节点链接法实现，嵌套法实现

- 每个节点保存根节点的数据项以及指向左右子树的链接
- 建议表达式解析树时，用栈来记录跟踪父节点，节点下降则将下降前的节点push入栈，节点上升到父节点时，上升到pop出栈的节点即可
- 求值函数evaluate的递归三要素
  - 基本结束条件：叶节点是最简单的子树，没有左右子节点，其根节点的数据项即子表达树的值
  - 缩小规模：将表达式分为左子树，右子树
  - 调用自身：分别调用evaluate计算左子树和右子树的值然后将左右子树的值依照根节点的操作符进行计算从而得到表达式的值

### 树的遍历

- 前序遍历preorder:先访问根节点，再递归的前序访问左子树，最后前序访问右子树。
- 中序遍历inorder：先递归的中序访问左子树，再访问根节点，最后中序访问右子树
- 后序遍历postorder:先递归的后序访问左子树，再后序访问右子树，最后访问根节点

```python
def preorder(tree):
    if tree:
        print(tree.getRootVal())
        preorder(tree.getLeftChild())
        preorder(tree.getRightChild())
def postorder(tree):
    if tree != None:
        postorder(tree.getLeftChild())
        postorder(tree.getRightChild())
        print(tree.getRootVal())
def inorder(tree):
    if tree != None:
        inorder(tree.getLeftChild())
        print(tree.getRootVal())
        inorder(tree.getRightChild())
```

### 优先队列Priority Queue

- 出队和队列一样从队首出队，但数据项次序是由优先级来确定
- 高优先级排在队首，这样优先队列的入队操作就比较复杂。
- 使用二叉堆实现优先队列，出队和入队复杂度都是O(log n)
- 二叉堆逻辑结构是二叉树却是用非嵌套的列表来实现
- 最小key排在队首的称为最小堆min heap,最大key排在队首是最大堆 max heap

#### 完全二叉树

- 叶节点最多出现在最底层和此底层而且最底层叶节点都连续集中在最左边，每个内部节点都有两个子节点，最多有1个节点例外。

- 使用完全二叉树结构来近似实现平衡。
  - 节点下标为p,则其左子节点下标为2p,右子节点为2p+1,父节点下标p//2

#### 堆次序Heap Order:

任何一个节点x，其父节点p中的key均小于x中的key，这样，符合堆性质的二叉树，其中任何一条路径，均是一个已排序数列，根节点的key最小。

### 二叉堆实现

- 采用一个列表保存对数据，表首下标为0的项无用，但为了后面代码可以用到简单的整数乘除法，仍然保留。
- insert(key):如果新key直接加在列表末尾，会破坏次序，所以需要key沿着其路径上浮到其正确位置，新key的上浮也不会影响其他路径节点的堆次序。

```python
class BinHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0
    def insert(self,k):
        self.heapList.append(k)
        self.currentSize = self.currentSize + 1

    def perUp(self,i):   #上 浮
        while i//2 >0:   #沿着路径往上
            if self.heapList[i] < self.heapList[i//2]:   #当它小于父节点
                self.heapList[i//2],self.heapList[i] = self.heapList[i],self.heapList[i//2]
            i = i//2 #往上    
```

- delMin()方法：移走堆中最小的key：根节点heapList[1] ,然后使用最后一个节点来代替根节点，最后下沉，避免破坏次序。   下沉：选择较小的子节点下沉

### 二叉查找树BST Binary research tree

- 比父节点小的key都出现在左子树，大的在右子树 

### AVL树

- 利用AVL树实现ADT Map，基本与BST实现相同，不同在于二叉树的生成和维护过程。
- AVL树的实现中，需要对每个节点跟踪平衡因子balance factor,平衡因子即左右子树高度差，大于0则左重。
- 如果一个二叉查找树每个平衡因子都在-1，0，1之间，就称作平衡树。
- AVL复杂度为O(log n).

# 图Graph

- 顶点Vertex,也称作节点Node，是图的基本组成部分，顶点具有名称标识的Key也可以携带数据项payload
- 边Edge，也称作弧Arc，作为两个顶点间关系的表示，边连接两个顶点，可以是无向或有向的，相应的图称作无向图和有向图。
- 权重Weight，为了表达从一个顶点到另一个顶点的代价，可以给边赋权，例如公交网络中两个站点之间的距离，通行时间和票价都可以作为权重，具有权重的图称为赋权图。
- 图G可以定义为G = (V,E),V是顶点的集合，E是边的集合，E中的每条边e = (V,W),v和w是都是V中的顶点。如果是赋权图，则可以在e中添加权重分量子图：V和E的子集。
- 圈Cycle，指首尾顶点相同的路径，若有向图中不存在任何圈，则称作有向无圈图DAG(directed acyclic graph)，有向无圈图可以用图算法很好的解决。

## 邻接矩阵Adjacency Matrix

- 矩阵的每行每列代表图的顶点，如果两个顶点之间有边相连，设定行列值
- 无权边则将矩阵分量标准为1或0。
- 优点是简单，易得到顶点如何连接，
- 缺点是如果图的边数很少则效率低下，称为稀疏sparse矩阵，而大多数问题对应的图都是稀疏的。

## 邻接列表Adjacency List

- 是稀疏图的更高效方案
- 维护一个包含所有顶点的主列表，主列表的每个顶点，再关联一个与自身有边连接的所有顶点的列表。
- 存储空间更高效，易获得顶点所连接的所有顶点以及连接边的信息。

### 词梯Word Ladder

- 目标是找到最短的单词序列
- 用广度优先搜索Breadth First Search 算法对单词关系图进行搜索。
- BFS是搜索图的最简单算法之一

### BFS广度优先搜索

- BFS搜索所有从s可到达顶点的边并且再达到更远的距离K+1的顶点之前，BFS会找到全部距离为K的顶点
- 为了跟踪顶点的加入过程，并避免重复顶点，要为顶点增加3个属性:
  - 距离distance:从起始顶点到此顶点路径长度
  - 前驱顶点predecessor:可反向追溯到起点
  - 颜色color：标识了此顶点是尚未发现(白色),已经发现(灰色),已经完成探索(黑色)
  - 队列Queue:对已发现的顶点进行排列，决定下一个要探索的顶点(队首顶点)
- 复杂度O(|v|+|e|)

# 骑士周游：

- 马把棋盘上每个格子都走一遍。   总共64个格子
-  图搜索算法是解决骑士周有问题最易理解和编程的方案之一
- 解决方案：1.将合法走棋次序表示为一个图 2.采用图搜索算法搜寻一个长度为(行×列-1)的路径，路径上包含每个顶点恰好一次

### 通用的深度优先搜索算法

- 在图上进行尽量深的搜索，连接尽量多的点，必要时可以进行分支，有时深度优先会创建多棵树，称为深度优先森林。
- 深度优先搜索同样要用到顶点的前驱属性，设置发现时间(第几步访问到这个顶点，灰色)和结束时间(第几部完成了此顶点探索，设置黑色)
- 复杂度同BFS



