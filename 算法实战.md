### 二分查找

- 每次排除一半的元素，对于n个元素的有序列表，最多log2(n)步。

- 思路:数组第一个元素索引low = 0,最后一个索引high = len(list-1),每次检查中间元素mid = (low+high)/2,如果mid<guess，则修改low = mid+1,否则high = mid - 1

- ```python
  def binary_search(list,item):
      low = 0
      high = len(list) - 1
      while low <= high:      #考虑到特殊情况，即只包含一个元素的情况
          mid = (low + high) // 2  
          guess = list[mid]
          if guess == item:
              return mid
          if guess < item:
              low = mid+1
          else:high = mid - 1
      return None
  
  a = [1,3,4,6,7,8,9,14,56,7886]  
  print(binary_search(a,90))     #None
  print(binary_search(a,7))      #4
  ```

### 大O表示法

- 仅仅知道算法需要多长时间才能运行完毕并不够，还需知道运行时间如何随列表增长而增加，这正是大O表示法的意义。
- 大O表示法指出了最糟情况下的运行时间
- 常见的大O运行时间
  - O(log n),对数时间，如二分查找
  - O(n),线性时间，如简单查找
  - O(n * log n)，如快速排序
  - O(n^2),如选择排序
  - O(n!),如旅行商问题的解决方案
- 算法的速度并非时间，而是操作数的增速
- 讨论算法速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。、

### 链表与数组

- 数组中所有元素都是紧密相连的，因此添加新元素可能很麻烦，若没有了空间就得把数组移到内存的其他地方，所以添加新元素速度很慢。
- 链表中的元素可存储在内存的任何地方，每个元素都存储了下一个元素的地址从而使一系列随机的内存地址串在一起。因此链表添加新元素很容易:放入内存，将其地址存储到前一个元素中。
- 数组的优势:当需要跳跃读取时，链表效率很低，因为它需要从第一个元素开始读取从而获取地址，而数组的每个元素都有索引，可以迅速找到数组中的任何元素。由于很多情况都要求能够随机访问，因此数组用的比链表多。
  - 链表: 读取O(n)  插入O(1)   删除O(1)  (只需修改前一个元素指向的地址即可)
  - 数组:读取O(1)   插入O(n) (因为插入元素时，后面元素都得后移。且若没有足够的空间，还需要将整个数组复制到其他地方)   删除O(n) (前移后面的所有元素)

### 选择排序

- eg:将每首歌按照其播放次数进行排序
- 复杂度为O(n^2),每次都需要检查列表的每个元素，O(n),需要重复n次，因此总时间为O(n^2)

```python
def findSmallest(arr):
    smallest = arr[0]
    smallest_index = 0
    for i in range(1,len(arr)):
        if arr[i] < smallest:
            smallest = arr[i]
            smallest_index = i
    return smallest_index
def selectionSort(arr):
    newArr = []
    for i in range(len(arr)):
        smallest = findSmallest(arr)
        newArr.append(arr.pop(smallest))
    return newArr
print(selectionSort([7,10,70,90,99,50,55,900,421]))  #[7, 10, 50, 55, 70, 90, 99, 421, 900]
```

### 递归

- 递归只是让解决方案更清晰，并没有性能上的优势，有些情况下循环的性能更好。使用循环，程序的性能可能更高，使用递归，程序可能更易理解，如何选择要看什么对你来说更重要。
- 每个递归函数都有两部分:基线条线base case和递归条件 recursive case，递归条件是让函数调用自己而基线条件是让函数不再调用自己。

### 栈

- eg:一叠便条，插入时放在最上面，拿走时也是拿走最上面的那一张
- 调用栈:计算机在内部使用调用栈，调用一个另一个函数时，当前函数暂停且处于未完成状态，另一个函数的内存块会叠到当前函数的内存块上，调用完毕后挪走。
- 栈在递归中扮演者主要角色
- 使用栈虽然方便，但也要付出代价:存储详尽的信息可能占用大量内存，每个函数调用都要占用一定内存，若栈很高，就意味着计算机存储了大量函数滴哦用的信息，此时有2个选择:
  - 重新编写代码，转而使用循环
  - 使用尾递归(一个高级递归主题)

### 分而治之 divide and conquer D&C

- D&C并非可用于解决问题的算法，而是一种解决问题的思路

- eg:将土地均匀的分成方块且尽可能大   使用D&C解决问题有两个步骤:

  - 找出基线条件，此条件必须尽可能简单(一条边的长度是另一条边的整数倍)
  - 不断将问题分解，直到符合基线条件

  ```python
  #sum问题
  def sumlist(list):
      arr = []
      if len(list) == 0:
          return 0
      else:
          return list[0]+sumlist(list[1:])  
  print(sumlist([1,2,3,4,5,6]))   #21
  
  #计算列表包含的元素数
  def sumIndex(list):
      if len(list) == 0:
          return 0
      else:
          return 1+sumIndex(list[1:])
  print(sumIndex([1,2,3,4]))     #4
  ```

### 快速排序

- 复杂度为O(nlogn)，最糟情况复杂度为O(n^2).平均情况下分区log n 次，最糟情况分区n次,每个元素都要和基准值进行比较，共比较n次，总复杂度为O(nlogn)
- 快速排序是最快的排序算法之一，D&C典范！

- 首先从数组中选择一个元素，成为基准值pivot,然后找出比基准值小的元素和大的元素，这成为分区，那么现在就有了:

  - 一个由所有小于基准值的数字组成的子数组
  - 基准值
  - 一个由所有大于基准值的数字组成的子数组

- 然后在对子数组进行排序，在合并即可。

- ```python
  def quicksort(array):
      if len(array) < 2:
          return array
      else:
          pivot = array[0]
          less = [i for i in array[1:] if i <=pivot]
          greater = [i for i in array[1:] if i > pivot]
          return quicksort(less) + [pivot] +quicksort(greater)
  print(quicksort([5,89,3,4,67,54,457]))   #[3, 4, 5, 54, 67, 89, 457]
  ```

### 快速排序与合并排序

- 快速排序平均情况下运行时间是O(nlogn),最糟情况是O(n^2)合并排序运行时间总是O(nlogn)
- C是算法所需的固定时间量，成为常量，如简单查找常量为10ms,则其需要时间为10ms * n,二分查找常量为1s，则其所需时间为1s * logn，但部分情况下常量影响很小
- 但是在有些情况下常量影响很大，如快速排序和合并排序，虽然复杂度相同，但快速排序明显快于合并排序。

### 散列表

#### 1.散列函数

- 无论你给它什么数据，它都还你一个数字，即将输入映射到数字，平均情况下查找，插入，删除的复杂度都是O(1)
- 散列函数必须满足的要求:
  - 它必须是一致的，假设你输入apple时得到的4，那么你每次输入apple得到的都必须是4，否则散列表将毫无用处
  - 它应该将不同的输入映射到不同的数字，假如一个散列函数不管输入什么都返回1，那么它不是一个好的散列函数，理想情况是将不同的输入映射到不同的数字。
- 散列表使用散列函数来确定元素的存储位置，也被称为散列映射、映射、字典和关联数组。任何优秀的语言都提供了散列表实现，如Python中为dict(),JS中为对象。
- 散列表用于大海捞针式的查找，如访问如www.baidu.com这样的网站时，计算机必须将url转为IP地址，这就是把网址映射到IP地址，此过程称为DNS解析(DNS resolutio)。

#### 2.将散列表用于缓存

- 缓存是常用的加速方式，所有大型网站都用缓存，而缓存的数据则存储在散列表中

- ```python
  # 工作原理
  cache = {}
  def get_page(url):
      if cache.get(url):
          return cache[url]
      else:
          data = get_data_from_sever(url)
          cache[url] = data
          return data
  ```

#### 3.冲突 collision

- 给两个数分配的位置相同
- 最简单的处理办法:若两个键映射到同一个位置则在这个位置存储一个链表，但这会降低速度。
- 散列函数很重要，理想情况是将散列函数均匀地映射到散列表的不同位置
- 若散列表存储的链表很长，散列表速度会急剧下降，然而若使用的散列函数很好，这些链表就不会很长
- 为避免冲突，需有:
  - 较低的装填因子
  - 良好的散列函数

