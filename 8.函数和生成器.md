# 函数基础

- #### 函数相关的语句和表达式

  | 语句或表达式   | 示例                                                         |
  | -------------- | ------------------------------------------------------------ |
  | 调用表达式     | func(1)                                                      |
  | def            | def printer(message):print('hello' + message)                |
  | return         | def adder(a,b):return a+b                                    |
  | global         | x = 'old' def changer():global x;x = 'new'    作用是在局部作用域使用全局变量x |
  | nonlocal       | def outer():x = 'old'    def changer():nonlocal x;x = 'new'  |
  | yield          | def squares(x):for i in range(x):yield i**2                  |
  | lambda匿名函数 | funcs = [lambda x:x **2,lambda x : x * *3]                   |

### 为何使用函数

- 最大化代码重用和最小化代码冗余
- 过程分解

### 函数说明

- def是可执行的代码。
- def创建了一个对象并将其赋值给某一变量名
- lambda创建了一个对象并将其作为结果返回
- return将一个结果对象传给调用者
- yield向调用者发回一个结果对象，但是会记住它离开的位置。像生成器这样的函数也可以通过yield语句来返回值，并挂起它们的状态以便稍后能恢复。
- global声明了一个模块级的可被赋值的变量。默认情况下所有在一个函数中被赋值的对象都是这个函数的局部变量且仅在这个函数运行过程中存在。为了给它的一个外层模块的变量赋值，函数需要在global语句中声明它
- nonlocal声明了一个需要被赋值的外层函数变量。nonlocal语句允许一个函数对一个在其外层的def语句作用域中已有的名称进行赋值，这就把外层函数用作了保留状态的仓库，也就是说同一函数在不同次的调用之间可以不必借助全局变量而存储信息。
- 参数是通过赋值传递给函数的
- 除非显式指明形式参数与实际参数的对应否则实际参数按位置赋值给形式参数
- 参数、返回值与变量不需要声明。

### 函数的多态

```python
def time(x,y):
    print(x * y)
time(4,3)         #12
time('NI',4)      #NINININI
#time()的作用取决于传递给它的值，这样依赖类型的行为称为多态，即操作的意义取决于被操作对象的意义，这也是Python和静态类型语言(C++、Java)在语言设计哲学上的重大差异，在Python中你的代码不应该关心特定的数据类型。
#但是如果传入了不支持接口的对象就会报错
```

### 变量名解析：LEGB规则

- 当在函数中使用未限定的变量名时，Python将查找4个作用域并在第一次找到该变量名的地方停下来：首先是局部作用域L,其次是向外一层的def或lambda的局部作用域E，之后是全局作用域G，最后是内置作用域B。
- 内置作用域指在内置模块中预先赋值好的名称，例如open,range,SyntaxError.
- 这个规则仅适用于简单变量名，如spam，被验证的属性变量名如object.spam 会存在于特定的对象中且遵循一种完全不同的查找规则而不属于这里提到的作用域概念。后面跟着点号的属性名引用会查找一个或多个对象而不是作用域，事实上它与Python的OOP模型名为继承的概念相关。