# 11.类与对象

- OOP:Object-Oriented Programming,面向对象程序设计
- OOP的意义:通过分解代码、最小化代码的冗余以及对已有代码进行定制来编写程序，而不是原处修改代码或从头开始

### 类的3个独特之处

- 多重实例:类实质上是产生对象的工厂，每当调用一个类时就会产生一个有独立命名空间的新对象，每个由类产生的对象都能读取类的属性并获得自己的命名空间来存储数据，这些数据是属于每个对象本身的。
- 通过继承进行定制:类支持OOP的继承的概念，可以在类的外部编写子类来重新定义其属性而扩充这个类.
- 运算符重载:通过特定的协议方法，类可以定义对象来响应在内置类型上的一些运算，如通过类创建的对象可以进行切片、拼接和索引等运算，python提供了一些由类使用的钩子，从而能拦截且实现任何的内置类型运算。

### 属性继承搜索

- object.attribute，找到attribute首次出现的地方，先搜索object,然后是该对象之上的所有类，由下往上，由左到右，也就是说属性访问就只是搜索类树而已，这种搜索称为继承，因为树中位置较低的对象继承了树中位置较高的对象所拥有的属性，当从下至上搜索时，连接至树中的对象就是所有父节点定义的所有属性的并集，直至树的根部。
- 类与实例:
  - 类:类是实例工厂，类的属性提供了行为(数据、函数)，所有从类产生的实例都继承该类的属性。
  - 实例:代表程序领域中具体的元素，实例的属性记录了每个实例自己的数据。
- 子类可能会在树中较低位置重新定义父类的名称从而覆盖父类的行为。
- Python把隐含的实例传入方法中特殊的第一位参数，习惯上称为self，方法提供这个参数来处理调用的主体。

```python
class C2:
class C3:
class C1(C2,C3):   #C2,C3是C1的父类，搜索时从左至右搜索
I1 = C1()
I2 = C1()
```

- 属性通常是通过self赋值来附加给实例的，而这个self参数也被传入类中编写的方法函数。
- __ init __，称为构造函数，每次从类产生实例时都会自动调用此方法

```python
class C1():
    def __init__(self,name):
        self.name = name
I1 = C1('zjw')
I2 = C1('xuanshen')
print(I1.name)
```

#### 多态：

```python
class Employee:
    def Salary(self,salary):
        self.Salary = 50
class Engineer(Employee):  #此时engineer继承了employee，但重新定义了salary方法，那么会覆盖父类的方法，这就叫多态，多态指运算的意义取决于运算的对象，即代码不关心它处理的对象是什么，只关心这个对象应该做什么。
    def Salary(self,salary):
        self.Salary = 80
```

#### Python类的主要特性

- class语句创建类对象并将其赋值给一个名称
- class语句内的赋值语句会创建类的属性
- 类属性提供了对象的状态和行为

#### 实例对象特性

- 像函数那样调用类对象会创建新的实例对象
- 每个实例对象继承了类的属性且获得了自己的命名空间
- 在方法内对self属性做赋值运算会产生每个实例自己的属性



- 位于类中的函数通常称为方法，一般用def语句编写，方法函数在调用时，第一位参数自动接收隐含的实例对象，即调用主体。
- 类是模块内的属性，使用其他文件内的类需要导入

#### 运算符重载

- 以双下划线命名的方法__ x __ 是特殊钩子
- 当实例出现在内置运算中时，这类方法会自动调用
- 类可以重载绝大多数内置类型运算
- 默认的运算符重载方法既不存在也不需要
- 新式类有一些默认的运算符重载方法，但不属于常见运算
- 运算符将类与Python的对象模型结合到一起

```python
a = student('zjw',55)
a.printname()
print(a.__class__)      #<class '__main__.student'> __ class__方法可以查看实例属于哪一个类
print('------------')
print(student.__bases__) #(<class 'object'>,)    __ bases__方法可以查看父类
```

- 类与模块:类总是位于模块中，类是模块对象的属性，类和模块都是命名空间，但类对应于语句且支持多个实例、继承以及运算符重载这些OOP概念(模块不支持)。某种意义上，模块像是单一实例的类，无继承，而且模块对应于整个文件的代码